// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/interfaces/IERC1363Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/interfaces/IERC1363ReceiverUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/interfaces/IERC1363SpenderUpgradeable.sol";
/// @title Implementation of ERC1363
/// @dev All function calls are currently implemented using https://github.com/vittominacori/erc1363-payable-token
abstract contract ERC1363Upgradeable is
  Initializable,
  ERC20Upgradeable,
  IERC1363Upgradeable
{
  using AddressUpgradeable for address;

  function __ERC1363_init() internal view onlyInitializing {}

  function __ERC1363_init_unchained() internal view onlyInitializing {}

  /**
   * @dev Transfer tokens to a specified address and then execute a callback on `to`.
   * @param to The address to transfer to.
   * @param amount The amount to be transferred.
   * @return A boolean that indicates if the operation was successful.
   */
  function transferAndCall(address to, uint256 amount)
    public
    virtual
    override
    returns (bool)
  {
    return transferAndCall(to, amount, "");
  }

  /**
   * @dev Transfer tokens to a specified address and then execute a callback on `to`.
   * @param to The address to transfer to
   * @param amount The amount to be transferred
   * @param data Additional data with no specified format
   * @return A boolean that indicates if the operation was successful.
   */
  function transferAndCall(
    address to,
    uint256 amount,
    bytes memory data
  ) public virtual override returns (bool) {
    transfer(to, amount);
    require(
      _checkAndCallTransfer(_msgSender(), to, amount, data),
      "ERC1363Upgradeable: _checkAndCallTransfer reverts"
    );
    return true;
  }

  /**
   * @dev Transfer tokens from one address to another and then execute a callback on `to`.
   * @param from The address which you want to send tokens from
   * @param to The address which you want to transfer to
   * @param amount The amount of tokens to be transferred
   * @return A boolean that indicates if the operation was successful.
   */
  function transferFromAndCall(
    address from,
    address to,
    uint256 amount
  ) public virtual override returns (bool) {
    return _transferFromAndCall(from, to, amount, "");
  }

  function transferFromAndCall(
    address from,
    address to,
    uint256 amount,
    bytes memory data
  ) public virtual override returns (bool) {
    transferFrom(from, to, amount);
    require(
      _checkAndCallTransfer(from, to, amount, data),
      "ERC1363Upgradeable: _checkAndCallTransfer reverts"
    );
    return true;
    // return _transferFromAndCall(from, to,amount,data);
  }

  /**
   * @dev Transfer tokens from one address to another and then execute a callback on `to`.
   * @param from The address which you want to send tokens from
   * @param to The address which you want to transfer to
   * @param amount The amount of tokens to be transferred
   * @param data Additional data with no specified format
   * @return A boolean that indicates if the operation was successful.
   */
  function _transferFromAndCall(
    address from,
    address to,
    uint256 amount,
    bytes memory data
  ) internal returns (bool) {
    transferFrom(from, to, amount);
    require(
      _checkAndCallTransfer(from, to, amount, data),
      "ERC1363Upgradeable: _checkAndCallTransfer reverts"
    );
    return true;
  }

  /**
   * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
   * @param spender The address allowed to transfer to
   * @param amount The amount allowed to be transferred
   * @return A boolean that indicates if the operation was successful.
   */
  function approveAndCall(address spender, uint256 amount)
    public
    virtual
    override
    returns (bool)
  {
    return approveAndCall(spender, amount, "");
  }

  /**
   * @dev Approve spender to transfer tokens and then execute a callback on `spender`.
   * @param spender The address allowed to transfer to.
   * @param amount The amount allowed to be transferred.
   * @param data Additional data with no specified format.
   * @return A boolean that indicates if the operation was successful.
   */
  function approveAndCall(
    address spender,
    uint256 amount,
    bytes memory data
  ) public virtual override returns (bool) {
    approve(spender, amount);
    require(
      _checkAndCallApprove(spender, amount, data),
      "ERC1363Upgradeable: _checkAndCallApprove reverts"
    );
    return true;
  }

  /**
   * @dev Internal function to invoke `onTransferReceived` on a target address
   *  The call is not executed if the target address is not a contract
   * @param sender address Representing the previous owner of the given token value
   * @param recipient address Target address that will receive the tokens
   * @param amount uint256 The amount mount of tokens to be transferred
   * @param data bytes Optional data to send along with the call
   * @return whether the call correctly returned the expected magic value
   */
  function _checkAndCallTransfer(
    address sender,
    address recipient,
    uint256 amount,
    bytes memory data
  ) internal virtual returns (bool) {
    if (!recipient.isContract()) {
      return false;
    }
    bytes4 retval = IERC1363ReceiverUpgradeable(recipient).onTransferReceived(
      _msgSender(),
      sender,
      amount,
      data
    );
    return (retval ==
      IERC1363ReceiverUpgradeable(recipient).onTransferReceived.selector);
  }

  /**
   * @dev Internal function to invoke `onApprovalReceived` on a target address
   *  The call is not executed if the target address is not a contract
   * @param spender address The address which will spend the funds
   * @param amount uint256 The amount of tokens to be spent
   * @param data bytes Optional data to send along with the call
   * @return whether the call correctly returned the expected magic value
   */
  function _checkAndCallApprove(
    address spender,
    uint256 amount,
    bytes memory data
  ) internal virtual returns (bool) {
    if (!spender.isContract()) {
      return false;
    }
    bytes4 retval = IERC1363SpenderUpgradeable(spender).onApprovalReceived(
      _msgSender(),
      amount,
      data
    );
    return (retval ==
      IERC1363SpenderUpgradeable(spender).onApprovalReceived.selector);
  }

  /**
   * @dev This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[50] private __gap;
}
